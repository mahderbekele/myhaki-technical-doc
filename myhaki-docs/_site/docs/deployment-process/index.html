<h1>Deployment Process</h1>
<h2>Frontend Deployment (LSK Dashboard &amp; Informational Site)</h2>
<ul>
<li><strong>Platform:</strong> Vercel (Next.js/Tailwind)</li>
<li><strong>Branch:</strong> Auto-deployment from <code>main</code></li>
<li><strong>Environment Variables:</strong> Managed securely via <code>.env</code> in Vercel dashboard</li>
<li><strong>Build &amp; Preview:</strong> Each PR triggers preview builds; production deploys on merge to <code>main</code></li>
<li><strong>Brand Compliance:</strong> Ensure final builds use MyHaki colors, fonts, and logo (<a href="images/brand-guideline.png">see Brand Guideline</a>)</li>
</ul>
<p><strong>Steps</strong></p>
<ul>
<li>Developers create feature branches from the <code>main</code> branch to work on updates.</li>
<li>Code changes are committed and pushed to the remote repository.</li>
<li>A Pull Request (PR) is opened targeting the <code>main</code> branch.</li>
<li>Vercel automatically generates preview builds for each PR, allowing team members to review the changes live.</li>
<li>Reviewers perform tests and validate the UI and functionality.</li>
<li>Brand compliance is enforced by verifying the use of MyHaki colors, fonts, and logo according to the brand guidelines.</li>
<li>After approval, the PR is merged into <code>main</code>.</li>
<li>Vercel initiates an automatic production deployment from <code>main</code>.</li>
<li>Environment variables are injected securely during build time from the Vercel dashboard <code>.env</code>.</li>
<li>Final validation confirms the live site aligns with brand requirements and functions correctly.</li>
</ul>
<hr>
<h2>Mobile Deployment (Android App)</h2>
<ul>
<li><strong>Platform:</strong> Google Play Console (Production), Firebase App Distribution (Testing)</li>
<li><strong>Build:</strong> Release builds via Gradle (<code>assembleRelease</code>), signed with team keystore</li>
<li><strong>Environment Variables:</strong> API URLs, keys stored in <code>local.properties</code> and encrypted secrets</li>
<li><strong>CI:</strong> GitHub Actions runs unit/UI tests on push; releases only after passing all tests</li>
<li><strong>Brand Compliance:</strong> All assets, colors, and typography must match MyHaki guidelines</li>
</ul>
<p><strong>Steps</strong></p>
<ul>
<li>Feature development occurs on dedicated branches.</li>
<li>Changes are pushed to GitHub, triggering automated unit and UI tests through GitHub Actions.</li>
<li>Upon successful tests, the Gradle build process is initiated using <code>assembleRelease</code>.</li>
<li>The generated APK is signed using the team’s keystore.</li>
<li>Environment variables such as API URLs and keys are securely managed via <code>local.properties</code> and encrypted secrets.</li>
<li>Release APKs are distributed through two channels:</li>
<li>Firebase App Distribution for testing builds.</li>
<li>Google Play Console for production release.</li>
<li>Prior to submission, all assets and UI elements are verified to meet MyHaki’s brand compliance standards.</li>
<li>The production APK is published officially on Google Play after all validations.</li>
</ul>
<hr>
<h2>Backend Deployment (Django REST API)</h2>
<ul>
<li><strong>Platform:</strong> Heroku (Staging &amp; Production)</li>
<li><strong>Branch:</strong> Deploy from <code>main</code></li>
<li><strong>Environment Variables:</strong> Managed securely in Heroku dashboard; never commit secrets</li>
<li><strong>Scaling:</strong> Automatic scaling via Heroku dynos based on demand</li>
<li><strong>Rollback:</strong> Previous stable releases can be redeployed via Heroku dashboard</li>
</ul>
<p><strong>Steps</strong></p>
<ul>
<li>Development and code changes happen on feature branches.</li>
<li>GitHub Actions run automated tests and linting upon each push.</li>
<li>Merging into the <code>main</code> branch triggers a Heroku deployment.</li>
<li>Heroku pulls the latest code and deploys it to the staging or production environment.</li>
<li>Environment variables and secrets are securely managed within the Heroku dashboard, never committed to code.</li>
<li>Heroku Dynos scale automatically based on live traffic demands.</li>
<li>In the event of deployment issues, rollback to previous stable releases is possible directly from the Heroku dashboard.</li>
</ul>
<hr>
<h2>AI Agent Deployment (FastAPI)</h2>
<ul>
<li><strong>Platform:</strong> Google Cloud Platform (Cloud Run, GKE, or Compute Engine)</li>
<li><strong>Build:</strong> Dockerized FastAPI microservice</li>
<li><strong>Environment Variables:</strong> Managed in Google Cloud Secret Manager</li>
<li><strong>Scaling:</strong> Automatic scaling via Google Cloud Run/GKE</li>
<li><strong>Monitoring:</strong> Use Google Cloud Monitoring for logs, alerts, and uptime</li>
</ul>
<p><strong>Steps</strong></p>
<ul>
<li>Developers push changes on feature branches and open PRs.</li>
<li>GitHub Actions verify code quality, run tests, lint, and build Docker images upon each push.</li>
<li>After tests are successful, merging into <code>main</code> triggers deployment pipelines.</li>
<li>Docker images are pushed to Google Container Registry.</li>
<li>Automatic deployment happens on Google Cloud Run, GKE, or Compute Engine.</li>
<li>Environment variables and secrets are managed securely in Google Cloud Secret Manager.</li>
<li>Monitoring is handled through Google Cloud Monitoring for logs, uptime, and alert notifications to maintain service reliability.</li>
</ul>
<hr>
<h2>CI/CD Pipeline</h2>
<ul>
<li><strong>Tool:</strong> GitHub Actions</li>
<li><strong>Pre-Deployment:</strong> All codebases run tests, build, and lint checks before deploy</li>
<li><strong>Automation:</strong> Automatic deployment on merge to <code>main</code></li>
<li><strong>Status:</strong> Build/test status visible in PRs and repository dashboard</li>
<li><strong>Security:</strong> Secrets scanned before deploy, API keys never exposed</li>
</ul>
<p><strong>Steps</strong></p>
<ul>
<li>Code pushed to feature or <code>main</code> branches triggers GitHub Actions workflows.</li>
<li>Workflows run tests, build processes, and static analysis (linting).</li>
<li>Secrets and API keys are scanned to prevent leaks before deployment.</li>
<li>Only code passing all validations can be merged into the <code>main</code> branch.</li>
<li>Merging to <code>main</code> automatically starts deployment of respective components.</li>
<li>Real-time build and deployment statuses are displayed on pull requests and repository dashboards.</li>
<li>Failures in tests or security scans immediately block deployments, ensuring only stable code is delivered.</li>
</ul>
<hr>
<h2>Deployment Flow Diagram</h2>
<p><img src="images/deployment-diagram.png" alt="Deployment Architecture"></p>
<hr>
<h2>Release Checklist</h2>
<ul>
<li>[x] All tests passing (unit, integration, UI)</li>
<li>[x] Linting with zero errors</li>
<li>[x] Secrets verified (no <code>.env</code> in repo)</li>
<li>[x] Brand assets up to date</li>
<li>[x] Team notified of release</li>
</ul>
<hr>
<h2>References</h2>
<ul>
<li><a href="images/brand-guideline.png">Brand Guideline</a></li>
<li><a href="code-standards.md">Code Standards</a></li>
<li><a href="qa-process.md">QA Process</a></li>
<li><a href="api-reference.md">API Reference</a></li>
</ul>
<hr>
<style>
  summary {
    cursor: pointer;
    font-weight: bold;
    color: #A87352;
    padding: 8px;
    border: 1px solid #621616;
    border-radius: 5px;
    margin-bottom: 5px;
    background-color: #f9f5f2;
  }
  details[open] summary {
    background-color: #621616;
    color: #A87352;
  }
  details {
    border: 1px solid #621616;
    border-radius: 7px;
    padding: 10px 15px;
    margin-bottom: 15px;
    background-color: #fff8f5;
  }
  li {
    margin-bottom: 6px;
    color: #621616;
  }
</style>
